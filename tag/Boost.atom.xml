<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Aldrin's Notebook</title><link href="http://aldrin.co/" rel="alternate"></link><link href="http://aldrin.co/tag/Boost.atom.xml" rel="self"></link><id>http://aldrin.co/</id><updated>2013-03-08T00:00:00+05:30</updated><entry><title>Coroutines in C++ (incomplete...)</title><link href="http://aldrin.co/coroutines.html" rel="alternate"></link><updated>2013-03-08T00:00:00+05:30</updated><author><name>Aldrin J D'Souza</name></author><id>tag:aldrin.co,2013-03-08:coroutines.html</id><summary type="html">&lt;p&gt;The ideal subroutine is a mathematical function; you give it inputs and it returns the results of
the computation. It has a single entry point, all data local to it is initialized upon entry and is
cleaned up when it returns back to the caller. The next call, if any, starts all over again and no
local residues are carried over from the last time. A coroutine is an interesting deviation from
these well set conventions. Unlike a subroutine, a coroutine is not required to be atomic; it can
&lt;em&gt;yield&lt;/em&gt; control back to the caller as soon as there are partial results that can be used. Moreover,
it can &lt;em&gt;resume&lt;/em&gt; the computation from where it left when the invoked again.&lt;/p&gt;
&lt;p&gt;These yield-resume semantics make coroutines a better abstraction for certain problems. In the
following, I walk through some such problems and implement their solutions using
&lt;a href="http://www.boost.org/doc/libs/release/libs/coroutine/doc/html/index.html"&gt;Boost.Coroutine&lt;/a&gt;. Let's start with &lt;a href="http://www.python.org/dev/peps/pep-0255/"&gt;generators&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;Generators&lt;/h4&gt;
&lt;p&gt;Consider the problem of writing a routine that checks if two binary trees have the &lt;em&gt;same fringe&lt;/em&gt;
i.e.  if they have exactly the same leaves reading from left to right. For example, the blue trees
below all have the same fringe while none of them have the same fringe as the red one.&lt;/p&gt;
&lt;p&gt;&lt;img src="/static/images/samefringe.png"&gt;&lt;/p&gt;
&lt;p&gt;How would we write a routine that takes two &lt;a href="https://github.com/aldrin/home/blob/master/code/c%2B%2B/misc/tree.h"&gt;binary trees&lt;/a&gt; and checks if they have the same
fringe?&lt;/p&gt;
&lt;p&gt;Simple, check if the post-order traversals of the two trees are the same. That works but is
suboptimal as it requires us to access &lt;em&gt;all&lt;/em&gt; leaf nodes in both the trees, always. Looking at all
nodes is &lt;em&gt;necessary&lt;/em&gt; before returning a &lt;code&gt;true&lt;/code&gt; but we should be able to return &lt;code&gt;false&lt;/code&gt; sooner. For
example, given the red and any of the blue trees from above, we can return a &lt;code&gt;false&lt;/code&gt; after looking
at just the first node from the two trees. To do that we would have to compare the trees one leaf at
a time. The routine would have to descend down to the first leaf and yield control back to the
caller with the leaf value. The caller would then compare the values of two leaves received and
return &lt;code&gt;false&lt;/code&gt; if they don't match or return control back to the routines to resume their
traversals.  Pause a little while here and consider writing a subroutine that can do this.&lt;/p&gt;
&lt;p&gt;The example, though academic, gives us insight that a coroutine based generator is better when it
makes sense to return partial results early and resume the remaining computation only if
needed. &lt;a href="https://github.com/aldrin/home/blob/master/code/c%2B%2B/boost/coro_samefringe.cpp"&gt;Here's&lt;/a&gt; how we do that for the problem above:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;misc/tree.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;boost/bind.hpp&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;boost/coroutine/all.hpp&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;ajd&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;binary_tree&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;tree&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;boost&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;coroutines&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;coroutine&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;generator&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;next_leaf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;generator&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;caller_type&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;caller&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;next_leaf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;caller&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;next_leaf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;caller&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;is_leaf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;caller&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;same_fringe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="n"&gt;two&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;generator&lt;/span&gt; &lt;span class="n"&gt;leaf1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;boost&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;next_leaf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="n"&gt;generator&lt;/span&gt; &lt;span class="n"&gt;leaf2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;boost&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;next_leaf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;two&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;leaf1&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;leaf2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// while one of the trees has a next leaf&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;leaf1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;leaf2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;// if both have a next leaf&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;leaf1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;leaf2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="c1"&gt;// compare the next leaf&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// next leaves don&amp;#39;t match. return false.&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="n"&gt;leaf1&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// advance the first tree traversal&lt;/span&gt;
      &lt;span class="n"&gt;leaf2&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// advance the second tree traversal&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="c1"&gt;// one tree has more leaves than the other.&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// leaf count mismatch. return false.&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// no mismatches found, return true.&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If you were (as I was) hoping that syntax would be as neat as it is for Python generators, it
isn't. The first thing to get used to is that the &lt;em&gt;logical coroutine&lt;/em&gt; we want to write is different
from the &lt;em&gt;actual function&lt;/em&gt; we have to write (i.e. &lt;code&gt;next_leaf&lt;/code&gt;.) The second is to realize that
coroutines work in pairs; they don't &lt;em&gt;return&lt;/em&gt; back to their caller, instead, they &lt;em&gt;call&lt;/em&gt; the caller
back.&lt;/p&gt;
&lt;p&gt;With these two things in mind, consider the routine &lt;code&gt;same_fringe&lt;/code&gt;. The first thing we do is create
two instances of type &lt;code&gt;generator&lt;/code&gt; each bound to one of the roots of the trees we're comparing.  The
&lt;code&gt;generator&lt;/code&gt; type is an instantiation of the &lt;code&gt;boost::coroutines::coroutine&lt;/code&gt; template class with the
&lt;em&gt;logical&lt;/em&gt; signature of the coroutine plugged in. Here, this logical signature is &lt;code&gt;char()&lt;/code&gt; because
the routine is expected to return &lt;code&gt;char&lt;/code&gt; values stored in the tree leaves.&lt;/p&gt;
&lt;p&gt;Next, remember that the coroutine will not &lt;em&gt;return&lt;/em&gt; these leaf values like a subroutines would,
instead, it will call another coroutine that represents the caller. A reference to this peer
coroutine is passed as the first argument to &lt;code&gt;next_leaf&lt;/code&gt;. The actual type of this first argument is
&lt;code&gt;boost::coroutines::coroutine&amp;lt;void(char)&lt;/code&gt; and the same is also available as the convenience typedef
&lt;code&gt;generator::caller_type&lt;/code&gt;. Think about it and it'll make sense.&lt;/p&gt;
&lt;p&gt;The rest of the comparison logic is implemented using three member functions of the
&lt;code&gt;boost::coroutines::coroutines&lt;/code&gt; class. The first is the conversion to &lt;code&gt;bool&lt;/code&gt; that allows us to check
if the coroutine is active (it stays active till &lt;code&gt;next_leaf&lt;/code&gt; ends). The second is a function call
operator that resumes a coroutine execution. So &lt;code&gt;leaf1()&lt;/code&gt; in &lt;code&gt;same_fringe&lt;/code&gt; resumes &lt;code&gt;next_leaf&lt;/code&gt; and
executes its code till it yields back by calling its caller. Note that &lt;code&gt;caller(node-&amp;gt;value)&lt;/code&gt; inside
&lt;code&gt;next_leaf&lt;/code&gt; does exactly the same thing, i.e. resumes the execution of &lt;code&gt;same_fringe&lt;/code&gt;. The last
method used is &lt;code&gt;get&lt;/code&gt; that is an accessor for the result computed by the last invocation of the
coroutine. The return type here is &lt;code&gt;char&lt;/code&gt; and we use it to compare the leaf nodes.&lt;/p&gt;
&lt;p&gt;Hopefully, that made sense.&lt;/p&gt;
&lt;h4&gt;Incomplete&lt;/h4&gt;
&lt;p&gt;This post is incomplete. Have more samples&lt;/p&gt;</summary><category term="C++"></category><category term="Boost"></category></entry></feed>